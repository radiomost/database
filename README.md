# Домашнее задание к занятию "`Базы данных, их типы`" - `Иванов Сергей`


### Инструкция по выполнению домашнего задания

   1. Сделайте `fork` данного репозитория к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/git-hw или  https://github.com/имя-вашего-репозитория/7-1-ansible-hw).
   2. Выполните клонирование данного репозитория к себе на ПК с помощью команды `git clone`.
   3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
      - впишите вверху название занятия и вашу фамилию и имя
      - в каждом задании добавьте решение в требуемом виде (текст/код/скриншоты/ссылка)
      - для корректного добавления скриншотов воспользуйтесь [инструкцией "Как вставить скриншот в шаблон с решением](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md)
      - при оформлении используйте возможности языка разметки md (коротко об этом можно посмотреть в [инструкции  по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md))
   4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`);
   5. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
   6. Любые вопросы по выполнению заданий спрашивайте в чате учебной группы и/или в разделе “Вопросы по заданию” в личном кабинете.
   
Желаем успехов в выполнении домашнего задания!
   
### Дополнительные материалы, которые могут быть полезны для выполнения задания

1. [Руководство по оформлению Markdown файлов](https://gist.github.com/Jekins/2bf2d0638163f1294637#Code)


## Задание 1. СУБД

**Кейс**

Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

### 1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

### 1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

### 1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

### 1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?

### 1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.

### 1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?

### 1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.

### 1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?

### 1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

*Приведите ответ в свободной форме.*

### Ответы:

### 1.1. Бюджетирование, аналитика, прогнозирование

Для задачи — **бюджетирование проектов, формирование аналитических отчётов и прогнозирование рисков**, ключевыми требованиями являются:

* **Целостность данных** (ACID-свойства);
* **Строгая структура данных** (реляционная модель);
* **Возможность сложной аналитики** и отчётности.

**Рекомендуемый тип СУБД:**

**Реляционная СУБД** — например, PostgreSQL, MS SQL Server.

**Почему:**
* Поддержка строгой схемы и проверок целостности (foreign keys, constraints);
* Надёжные транзакции (ACID);
* Развитые средства аналитики: оконные функции, CTE, агрегаты;

### 1.1* Хеширование занимает много времени — что делать?

Если хеширование используется в процессе расчётов (например, при проверке подлинности, сравнения или дедупликации), а не справляется по скорости:

**Решения:**

**1. Оптимизировать алгоритм:**
* Перейти на BLAKE3 или xxHash (намного быстрее, чем SHA256);
* Использовать аппаратные оптимизации — Intel SHA Extensions, AES-NI (автоматически задействуются в OpenSSL).

**2. Использовать быстрые библиотеки/API:**
* **C/C++**: libsodium, OpenSSL, BLAKE3
* **Python**: pyblake3, hashlib (если SHA достаточно)
* **Rust/Go**: встроенные реализации BLAKE3/SHA256

**3. Параллелизация:**
* BLAKE3 и некоторые реализации SHA могут работать в несколько потоков.

**1.2. Какую СУБД лучше использовать для лендингов и для CRM?**

**Лендинги — требования:**
* Очень высокая скорость записи (много лидов с разных проектов);
* Гибкость схемы, так как поля форм лидов могут меняться;
* Возможность быстро масштабироваться с ростом трафика.

**Рекомендуемый тип СУБД:**
* Документо-ориентированная NoSQL СУБД (например, MongoDB)

**Почему?**
* Хранение данных в виде JSON-документов даёт гибкость;
* Быстрые операции вставки;
* Масштабируемость — шардинг и репликация из коробки;
* Поддержка индексов для поиска по полям.

### 1.2.* Можно ли закрыть эту задачу одной СУБД? Если да — какой?
Да, можно.
**Лучший кандидат:**
PostgreSQL с JSONB

**Почему?**
Позволяет хранить гибкие данные лендингов в JSONB;
* Поддерживает реляционные связи и транзакции для CRM;
* Есть мощные индексы по JSONB полям для скорости запросов;
* Универсальная и открытая, много инструментов и сообществ;
* Можно масштабировать с помощью партиционирования и репликации.

**Альтернативы:**

**MongoDB**, если приоритет — гибкость и масштабируемость данных лендинга, но при этом CRM-логика будет сложнее реализована из-за отсутствия сложных реляционных связей и транзакций.

### 1.3. База норм, правил, обучающих материалов

**Требования:**
* Простая и понятная структура;
* Иерархичность (например: подразделение → правила → документы);
* Удобство доступа и обновления;
* Возможность быстрого поиска по заголовкам, категориям, ключевым словам;
* Возможна вложенность (например, подраздел 1.1 → документ → файлы).

**Рекомендуемый тип СУБД**
Реляционная СУБД:
* PostgreSQL;
* MySQL;
* SQLite (если маленький объём, офлайн-решение).

**Почему:**
* Простая и читаемая структура таблиц;
* Легко реализовать связи между сущностями (подразделы, документы, версии);
* Возможность полнотекстового поиска (например, PostgreSQL tsvector + GIN index);
* Поддержка JSONB, если нужно немного гибкости без усложнения схемы.

### 1.3*. Можно ли использовать уже существующую СУБД из задач выше?
Да, и это будет правильно.

**Преимущества повторного использования PostgreSQL:**
* Нет дублирования инфраструктуры;
* Единая точка доступа и авторизации;
* Простота резервного копирования и мониторинга;
* Удобная интеграция с другими системами (CRM, BI и т.д.).

### 1.4. Формирование маршрутов и распределение курьеров

**Задача:**
* Быстрая работа со связями между точками (объекты, курьеры, маршруты);
* Поддержка поиска кратчайших путей, маршрутов, кластеров;
* Часто меняющиеся данные (например, пробки, новые заказы);
* Требуется высокая скорость запросов "по графу".

**Рекомендуемый тип СУБД - Графовая СУБД:**
* **Neo4j** — лидер на рынке графовых СУБД;
* **ArangoDB** — мульти-модельная СУБД (граф + документы + ключ-значение);
* **OrientDB, JanusGraph** — альтернативы для больших систем.

**Почему графовая СУБД:**
* Отлично работает с узлами и рёбрами (объекты, курьеры, связи, дороги);
* Поддерживает алгоритмы маршрутизации (Dijkstra, A*, PageRank и др.);
* Запросы типа "найди кратчайший путь от склада до 5 объектов" — выполняются в разы быстрее, чем в RDBMS.

### 1.4*. Можно ли подключить отдел закупок к этой СУБД?

**Зависит от характера данных:**

**Если закупки — это больше "табличные" данные:**
* Номенклатура, поставщики, счета, спецификации, заказы, статусы и т.д.;
* Тогда лучше использовать реляционную СУБД (например, PostgreSQL), где легко отразить:
  * товар → заказ → поставщик → статус

**Но если закупки тесно интегрированы с логистикой (например: "что, куда, когда, кем доставляется"):**
* Тогда можно использовать связку:
   * PostgreSQL (закупки) ↔ Graph DB (логистика)
   * Или ArangoDB, которая умеет хранить и графы, и документы

**1.5*. Можно ли все задачи из кейса 1 решить одной СУБД?**

**Краткий ответ:**
Да, теоретически — можно.

**Практически — разумно только на начальном этапе или при умеренной сложности проекта.**

Для этого лучше всего подойдёт **PostgreSQL с расширениями**.

**Почему именно PostgreSQL?**
PostgreSQL — мощная реляционная СУБД с поддержкой:
* Строгой структуры и транзакций (для 1.1 — бюджетирование);
* Полу-структурированных данных через JSONB (для 1.2 — CRM и лиды);
* Полнотекстового поиска и иерархий (для 1.3 — база знаний);
* Геоданных и маршрутизации с помощью PostGIS (для 1.4 — логистика);
* Расширений под аналитические и графовые задачи:
   * pgRouting, ltree, pg_trgm, citext;
   * PostGIS — для геоданных и маршрутов;
   * Apache AGE или AgensGraph — для **графовых** запросов внутри PostgreSQL.

|Подзадача|Можно ли в PostgreSQL?|Как реализовать|
|---------|----------------------|---------------|
|1.1 Бюджеты|✅ Да|Классическая схема RDBMS, аналитика на SQL|
|1.1* Хеши|✅ Да (частично)|Внешнее API + кэш (Redis), хеши можно хранить в таблицах|
|1.2 Лендинги|✅ Да|JSONB + индексы, высокая скорость записи|
|1.2* CRM|✅ Да|Структура + связи + отчётность|
|1.3 База знаний|✅ Да|Таблицы + текстовый поиск + вложенные разделы (ltree)|
|1.4 Логистика|⚠️ Да, с расширениями|PostGIS + pgRouting или Apache AGE|
|1.4* Закупки|✅ Да|Отдельные схемы/таблицы, связь по ID|

**Ограничения "одной СУБД":**
* Сложность поддержки разных моделей данных в одной системе;
* Не самая высокая производительность на экстремальных графовых задачах (по сравнению с Neo4j);
* Если проект масштабируется — часто проще разделить БД по функционалу.

**Подведем итог:** 
|Критерий|	PostgreSQL как единая СУБД|
|-----|----|
|Простота архитектуры|✅ Да|
|Расширяемость	|✅ Да (через плагины)|
|Поддержка разных типов|✅ RDBMS + JSONB + PostGIS + текст + граф|
|Идеально для начала|✅ Да|
|На больших нагрузках|⚠️ Может потребовать разделения|


## Задание 2. Транзакции
### 2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

### 2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

*Приведите ответ в свободной форме.*

### Ответы:

### 2.1. Пополнение счёта вручную — 6 шагов успешной транзакции

**🔹 Шаг 1. Проверка данных**
* Валидация введённых пользователем данных (номер телефона, сумма, платёжный метод);
* Проверка, что номер активен, и сумма пополнения допустима.

**🔹 Шаг 2. Создание транзакции**
* Генерация записи в таблице transactions со статусом "ожидается" (pending);
* Присвоение уникального transaction_id.

**🔹 Шаг 3. Обращение к платёжному шлюзу**
* Система отправляет запрос в эквайринг/платёжный шлюз (например, YooKassa, Stripe, Тинькофф);
* Шлюз обрабатывает платёж и возвращает статус (успешно/неуспешно).

**🔹 Шаг 4. Подтверждение транзакции**
* Если платёж успешен:
   * Транзакция помечается как "успешная" (success);
   * Фиксируется время, сумма, источник оплаты.

**🔹 Шаг 5. Обновление баланса**
* Внутри одной транзакции БД:
   * Баланс пользователя увеличивается;
   * Запись в журнале операций (balance_log) фиксирует пополнение;
* Всё это должно быть атомарным.

**🔹 Шаг 6. Отправка уведомления**
* Пользователю отправляется уведомление: push, SMS, email;
* В интерфейсе обновляется баланс.*

### 2.1*. Автоплатёж — чем отличается
Автоплатёж — это запланированное автоматическое действие по заданным правилам. Логика почти та же, но добавляются подготовительные шаги.

**🔹 Шаг 0. Планировщик/триггер**
* Система определяет, что пора запускать автоплатёж (по расписанию, по событию: баланс ниже лимита);
* Запускается процесс автоплатежа от имени пользователя.

**🔹 Шаг 1. Проверка условий**
* Проверка, включён ли автоплатёж, есть ли лимит и подходящее время;
* Проверка доступности платёжного метода (например, карта не просрочена).

**🔹 Шаги 2–6 — как в ручном режиме:**
* Создание транзакции → запрос в шлюз → подтверждение → изменение баланса → уведомление.

**🔹 Дополнительно:**
* В случае неудачи: запись ошибки, повтор через N минут, уведомление пользователю;
* Можно настроить ограничение количества попыток или дневной лимит.

**Ключевая особенность автоплатежа:**
Это тот же процесс, но инициируется системой, а не пользователем.
Плюс важна **дополнительная защита и контроль лимитов**, чтобы не "списать по ошибке".

---

### Задание 3. SQL vs NoSQL

### 3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.

### 3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

*Приведите ответ в свободной форме.*

### Ответы:

### 3.1. Пять преимуществ SQL-систем (реляционных БД) по сравнению с NoSQL

|№|Преимущество SQL|Объяснение|
|---|---|---|
|1|Строгая схема данных (схема + типизация)|Таблицы с чётко определённой структурой и типами — предотвращают ошибки на этапе записи.|
|2|Поддержка транзакций (ACID)|SQL-СУБД гарантируют целостность данных, особенно важна атомарность и согласованность (например, в банковских операциях).|
|3|Зрелый и мощный язык SQL|Стандартизованный язык запросов с JOIN, GROUP BY, оконными функциями и вложенными подзапросами.|
|4|Развитые средства анализа и агрегации|Отлично подходит для сложной аналитики, отчётности и финансовых расчётов.|
|5|Расширенная экосистема и стабильность|Поддержка репликации, бэкапов, триггеров, представлений (views), функций, интеграции с BI-системами, давно обкатана в продакшене.|

### 3.1*. Преимущества NewSQL по сравнению с SQL и NoSQL

**NewSQL** — это класс современных СУБД, сочетающих:
* строгость SQL (ACID, транзакции, схема),
* масштабируемость и скорость NoSQL.

**Примеры:** CockroachDB, Google Spanner, TiDB, VoltDB, MemSQL (SingleStore).

**Преимущества NewSQL:**

|№|Преимущество NewSQL|Объяснение|
|---|---|---|
|1|Горизонтальное масштабирование|Как и NoSQL, NewSQL можно масштабировать по узлам без потери согласованности.|
|2|Полная поддержка SQL + ACID|В отличие от NoSQL, сохраняются транзакции, целостность, строгая схема.|
|3|Высокая доступность (HA)|Распределённая архитектура с автоматическим failover и репликацией.|
|4|Низкие задержки и высокая производительность|Благодаря распределённой архитектуре и оптимизированному движку.|
|5|Подходит для критичных систем|Например, финтех, e-commerce, где важны и масштаб, и транзакционность.|

**Краткое сравнение:**

|Свойство|SQL|NoSQL|NewSQL|
|---|---|---|---|
|Схема данных|Статическая|Гибкая|Статическая|
|Транзакции|✅ ACID|❌ или ограничено|✅ ACID|
|Масштабируемость|↕ Вертикально|↔ Горизонтально|↔ Горизонтально|
|Производительность|Высокая|Очень высокая|Очень высокая|
|Подходит для|ERP, финансы|BigData, IoT|Все критичные системы|



---

### Задание 4. Кластеры
Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.

На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?

*Приведите ответ в свободной форме.*

### Ответы:

---

**Задания,помеченные звёздочкой, — дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже разобраться в материале.**